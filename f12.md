# JavaScript Arrow Function
```
<!DOCTYPE html>
<html>
<body>

<h1>JavaScript Arrow Function</h1>
<pre>
ham mũi tên 
</pre>
  
  <script>
    function demo() {
      document.writeln("hàm thông thường");
    }
    
    // gọi hàm 
    demo();
    
    // cách khác tạo hàm
    var demo2 = function() {
      document.writeln("hàm vô danh");
    }
    
    // gọi hàm khi gán hàm cho 1 biến
    demo2();
    
  </script>

</body>
</html>

```
## vd 2
```
<!DOCTYPE html>
<html>
<body>

<h1>JavaScript Arrow Function</h1>
<pre>
ham mũi tên 
ưu điểm : ngắn gọn hàm thông thường 
</pre>
  
  <script>
  demo2 = () => {
    document.write("nội dung của hàm");
  }
  
  // gọi hàm 
  demo2();
    
    
    // hàm tính tổng
    tinhtong = (a, b) => {
      var c;
      c = a + b;
      return c;
    }
    
    var kq = tinhtong(2,3);
    document.write("<br>" + kq);
    
    
  </script>

</body>
</html>

```
# thực hành hàm =>
```
<!DOCTYPE html>
<html>
<body>

<h1>JavaScript Arrow Function</h1>
<pre>
ham mũi tên 
ưu điểm : ngắn gọn hàm thông thường 
</pre>
  
  <script>
    
    hello = () => {
      return "Hello World!";
    }
    
    // với các hàm chỉ có 1 dòng và có lệnh return cuối hàm thì có thể bỏ luôn {} chứa hàm và bỏ luôn return
    hello = () => "Hello World!";
 
    //
    simple = (message) => {
      document.write(message);
    }
    // hàm bên trên có chỉ 1 tham số là message
    simple2 = message => {
      document.write(message);
    }
  </script>

</body>
</html>

```
# JavaScript Classes
```
<!DOCTYPE html>
<html>
<body>

<pre>
JavaScript Classes
Lớp trong js ( class )
Khởi tạo đối tượng từ class
vs class Oto chúng ta đối tượng cụ thể xe ford 2345 khởi tạo từ class Oto
constructor ( hàm khởi tạo hay phương thức khởi tạo ) được chạy khi mà chúng ta khởi tạo đối tượng từ class 
từ khóa this bên trong class đại điện cho chính bản thân class đó
</pre>
  
  <script>
    class Oto {
      constructor(name, color, price, model) {
        // tạo ra các thuộc tính
        this.name_pro = name;
        this.color_pro = color;
        this.price_pro = price;
        this.model_pro = model;
      }
      // phương thức mới
      showThongTin() {
        document.write("<br>" + this.name_pro);
        document.write("<br>" + this.color_pro);
        document.write("<br>" + this.price_pro);
        document.write("<br>" + this.model_pro);
      }
    }
    
    // khởi tạo đối tượng từ class Oto dùng từ khóa new Class()
    var fadil123 = new Oto("fadil", "đen", 500000000, "2020");
    
    console.log(fadil123);
    
    var focus123 = new Oto("focus", "vàng", 6000000000, "2019");
    
    console.log(focus123);
    
    // gọi method trong class từ object
    focus123.showThongTin();
  
  </script>

</body>
</html>

```
# Kế thừa trong js
```
<!DOCTYPE html>
<html>
<body>

<pre>
Kế thừa trong javascript
Class cha và class con
Class con kế thừa class cha
extends là kế thừa
class Meo extends DongVat {
}
</pre>
  
  <script>
    
    // class cha
    class Car {
      constructor(brand) {
        this.carname = brand;
      }
      // method khác trong class Car
      present() {
        return 'I have a ' + this.carname;
      }
    }
    
    // class con
    class Model extends Car {
      // method khởi tạo class con 
      constructor(brand, mod) {
        // gọi đến constructor của class cha thông qua super()
        super(brand);
        this.model = mod;
      }
      // phương thức show()
      show() {
        // gọi đến method present() trong class cha từ bên trong 1 phương thức khác của class con
        return this.present() + ', it is a ' + this.model;
      }
      
    }
    
    var oto123 = new Model("vinfast", "fadil");
    var intro = oto123.show();
    document.write("<br>" + intro);
    
    
    
  </script>

</body>
</html>

```
# phương thức tĩnh
```
 <!DOCTYPE html>
<html>
<body>

<pre>

phương thức static ( tĩnh ) trong class js
khi chúng ta muốn gọi phương thức trong class
1 - khởi tạo đối tượng từ class
2 - tên đối tượng . tên phương thức bên trong class
class Oto {
  showInfo() {}
}

var oto1 = new Oto();
oto1.showInfo();

- từ khóa static tạo ra các phương thức tĩnh
- các phương thức tĩnh có thể được gọi mà không cần phải đối tượng từ class thông qua từ khóa new 

</pre>
  
  <script>
    class Car {
      // phương thức khởi tạo
      constructor(name) {
        this.name = name;
      }
      // phương thức tĩnh
      static hello() {
        document.write("Hello!!!");
      }
    }
    
    // gọi đến phương thức tĩnh
    // ClassName.StaticMethodName();
    Car.hello();
    </script>

</body>
</html>

```
# callback
```
<!DOCTYPE html>
<html>
<body>

<pre>
Một callback là hàm được truyền vào như là đối số tới hàm khác
Công nghệ này cho phép một hàm có thể gọi hàm khác 
Hàm callback có thể được chạy sau khi hàm gọi hàm callback đã chạy xong

setTimeout(function, milliseconds)
thực thui 1 hàm sau khi đã đợi X milliseconds

</pre>
  
  <script>
    
    setTimeout(function(){
      alert("đã đợi xong 5s");
    }, 5000);
   
    </script>

</body>
</html>

```
# callback interval
```
<!DOCTYPE html>
<html>
<body>

<pre>
Một callback là hàm được truyền vào như là đối số tới hàm khác
Công nghệ này cho phép một hàm có thể gọi hàm khác 
Hàm callback có thể được chạy sau khi hàm gọi hàm callback đã chạy xong

setInterval(function, milliseconds)
thực thi hàm đi thực thi lại theo 1 chu kỳ x mili giây 

</pre>
  
  <script>
    
    setInterval(function(){
      alert("show thông bao");
    }, 5000);
   
    </script>

</body>
</html>

```
# JavaScript Function Sequence
```
<!DOCTYPE html>
<html>
<body>

<h2>JavaScript Function Sequence</h2>

<p>JavaScript functions are executed in the sequence they are called.</p>

<p id="demo"></p>

<script>
function myDisplayer(some) {
  console.log(some);
}

function myFirst() {
  
  
  setTimeout(function() {
     myDisplayer("Hello");
  }, 3000);
 
  
}

function mySecond() {
  myDisplayer("Goodbye");
}
// gọi lần 1
myFirst();
// gọi lần 2 
mySecond();
</script>

</body>
</html>

```
# thực hành callback
```
<!DOCTYPE html>
<html>
<body>
callback là 1 hàm được truyền vào 1 hàm khác như 1 đối số


<script>
function myDisplayer(some) {
  console.log(some);
}

function myFirst(callback) {
  
  
  setTimeout(function() {
     myDisplayer("Hello");
    
    callback();
    // mySecond();
  }, 3000);
 
  
}

function mySecond() {
  myDisplayer("Goodbye");
}
// gọi lần 1
myFirst(mySecond);

</script>

</body>
</html>

```
# Promise
```
<!DOCTYPE html>
<html>
<body>
"Producing code" is code that can take some time
"Producing code" là 1 đoạn mã mà sẽ tiêu tốn 1 khoảng thời gian 

"Consuming code" is code that must wait for the result
"Consuming code" là đoạn code đợi kết quả thừ "Producing code"
A Promise is a JavaScript object that links producing code and consuming code
1 Promise là 1 đối tượng trong javascript mà liên kết quá trình sản xuất code và tiêu thụ code

  
  bước 1 : tạo đối tượng Promise bằng từ khóa new Promise()
  bước 2 : truyền vao new Promise() 1 hàm vô danh là function(){}
  bước 3 : hàm vô danh không có tên này có 2 tham số là resolve() và reject()
  resolve() tượng trưng cho thành công
  reject() tượng trưng cho quá trình thất bại 
  
  
 
<script>
  // sản xuất mã 
  let myPromise = new Promise(function(resolve, reject){
    
    let x = 21;
    if (x >= 18) {
      resolve();
    } else {
      reject();
    }
  });
  
  // tiêu thụ mã
  myPromise.then(function(){
    console.log("thành công");
  }, function() {
    console.log("thất bại");
  });


</script>

</body>
</html>

```
